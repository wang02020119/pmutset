#pragma once

// Classes:
//    Intel::XEON::PMU: Manages 3 fixed counters and up to 8 programmable counters.
//                      See 'doc/pmu.doc' for details including refs for constants.

#include <assert.h>
#include <sys/types.h>
#include <sched.h>
#include <errno.h>
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#define _GNU_SOURCE





/*
inline __attribute__((always_inline)) void DoNotOptimize(Tp& value) {
  asm volatile("" : "+m,r"(value) : : "memory");
}
*/



enum ProgCounterSetConfig {
  // +-----------------------------------------------------------------------------------------------+
  // | Intel architecturally significant metrics basic set good for Intel Skylake and later PMUs.    |
  // | All counters count user-code (ring 2) run only. Kernel code is ignored. Counters only see the |
  // | work the CPU HW thread executed it was configured against; see 'printConfiguration()'.        |
  // +-----------------------------------------------------------------------------------------------+
  // | Fixed        Counter 0: https://perfmon-events.intel.com/ -> Number of retired instructions   |
  // | Fixed        Counter 1: https://perfmon-events.intel.com/ -> Cycles elapsed not in halt state |
  // | Fixed        Counter 2: https://perfmon-events.intel.com/ -> Ref cycles elapsed in halt state |
  // | Programmable Counter 0: https://perfmon-events.intel.com/ -> LONGEST_LAT_CACHE.REFERENCE      |
  // | Programmable Counter 1: https://perfmon-events.intel.com/ -> LONGEST_LAT_CACHE.MISS           |
  // | Programmable Counter 2: https://perfmon-events.intel.com/ -> BR_INST_RETIRED.ALL_BRANCHES_PS  |
  // | Programmable Counter 3: https://perfmon-events.intel.com/ -> BR_INST_RETIRED.COND_NTAKEN	     |
  // +-----------------------------------------------------------------------------------------------+
  k_DEFAULT_XEON_CONFIG_0 = 0,
  k_DEFAULT_CONFIG_UNDEFINED = 1,
};


enum Support {
  k_FIXED_COUNTERS            = 3,    // All boxes have 3 fixed counters
  k_MAX_PROG_COUNTERS_HT_ON   = 4,    // When CPU hyper threading ON  prog counters 0,1,2,3 available
  k_MAX_PROG_COUNTERS_HT_OFF  = 8,    // When CPU hyper threading OFF prog counters mostly [0-7] available
                                      // See https://perfmon-events.intel.com by event for details
};



const u_int32_t IA32_PERF_GLOBAL_STATUS = 0x38e;
const u_int32_t IA32_PERF_GLOBAL_CTRL   = 0x38f;

// MSR to configure programmable counter
const u_int32_t IA32_PERFEVTSEL0      = 0x186;
const u_int32_t IA32_PERFEVTSEL1      = 0x187;
const u_int32_t IA32_PERFEVTSEL2      = 0x188;
const u_int32_t IA32_PERFEVTSEL3      = 0x189;
const u_int32_t IA32_PERFEVTSEL4      = 0x18a;
const u_int32_t IA32_PERFEVTSEL5      = 0x18b;
const u_int32_t IA32_PERFEVTSEL6      = 0x18c;
const u_int32_t IA32_PERFEVTSEL7      = 0x18d;

// Initial programmable counter values written here
const u_int32_t IA32_PMC0             = 0xc1;
const u_int32_t IA32_PMC1             = 0xc2;
const u_int32_t IA32_PMC2             = 0xc3;
const u_int32_t IA32_PMC3             = 0xc4;
const u_int32_t IA32_PMC4             = 0xc5;
const u_int32_t IA32_PMC5             = 0xc6;
const u_int32_t IA32_PMC6             = 0xc7;
const u_int32_t IA32_PMC7             = 0xc8;

const u_int32_t IA32_PERF_GLOBAL_STATUS_RESET = 0x390;

// Initial fixed counter values written here
const u_int32_t IA32_FIXED_CTR0       = 0x309;
const u_int32_t IA32_FIXED_CTR1       = 0x30a;
const u_int32_t IA32_FIXED_CTR2       = 0x30b;

// MSR to conifgure fixed counters
const u_int32_t IA32_FIXED_CTR_CTRL   = 0x38d;
const u_int64_t DEFAULT_FIXED_CONFIG  = 0x222;

// Overflow masks for programmable counter 0, fixed counter 0
// The others are generated by left shifting 
const u_int64_t PMC0_OVERFLOW_MASK      = (1ull<<0);  // 'doc/intel_msr.pdf p287'                                      
const u_int64_t FIXEDCTR0_OVERFLOW_MASK = (1ull<<32); // 'doc/intel_msr.pdf p287'                                      

// DATA
int       d_fid = -1;                             // file handle for MSR read/write
u_int16_t d_cnt = 4;                             // # programmable counters in use [0, k_MAX_PROG_COUNTERS_HT_OFF)
u_int64_t d_fcfg = DEFAULT_FIXED_CONFIG;                            // configuration for all fixed counters
u_int64_t d_pcfg[k_MAX_PROG_COUNTERS_HT_OFF] = {0x414f2e, 0x41412e, 0x4104c4, 0x4110c4,};// configuration for each programmable counter in [0, d_cnt)
/*
d_pcfg[0] = 0x414f2e;
d_pcfg[1] = 0x41412e;
d_pcfg[2] = 0x4104c4;
d_pcfg[3] = 0x4110c4;
*/



static inline int PMUcoreId(void){
  return sched_getcpu();
}



int PMUwrmsr(u_int32_t reg, u_int64_t data) {
  assert(d_fid>0);

  // printf("wrmsr reg 0x%x val 0x%lx\n", reg, data);

  if (pwrite(d_fid, &data, sizeof data, reg) != sizeof data) {
    fprintf(stderr, "Error: MSR write error on register 0x%x value 0x%lx: %s\n", reg, data, strerror(errno));
    return errno;
  }
  return 0;
}





static inline int PMUopen(int cpu) {
  assert(cpu>=0);
  assert(d_fid==-1);

  char msr_file_name[64];
  sprintf(msr_file_name, "/dev/cpu/%d/msr", cpu);

  d_fid = open(msr_file_name, O_RDWR);
  if (d_fid < 0) {
    fprintf(stderr, "Error: cannot open '%s': %s\n", msr_file_name, strerror(errno));                                                 
    return errno;
  }

  return 0;
}


int PMUreset(void) {
  int rc;

  if (d_fid<0) {
    if ((rc = PMUopen(sched_getcpu()))!=0) {
      return rc;
    }
  }

  assert(d_fid>0);

  // Turn off all counters global level (1st disablement)
  if ((rc = PMUwrmsr(IA32_PERF_GLOBAL_CTRL, 0))!=0) {
    return rc;
  }

  // Turn off all defined programmable counters (1st disablement)
  int msr = IA32_PERFEVTSEL0;
  for(u_int16_t i = 0; i < d_cnt; ++i, ++msr) {
    if ((rc = PMUwrmsr(msr, 0))!=0) {
      return rc;
    }
  }


  // Reset to 0 programmable counter values
  msr = IA32_PMC0;
  for(u_int16_t i = 0; i < d_cnt; ++i, ++msr) {
    if ((rc = PMUwrmsr(msr, 0))!=0) {
      return rc;
    }
  }

  
  // Clear overflow bits
  if ((rc = PMUwrmsr(IA32_PERF_GLOBAL_STATUS_RESET, 0))!=0) {
    return rc;
  }

  // Re-enable all fixed and defined programmable counters (first enablement)
  u_int64_t value = 0x700000000; // 'doc/pmd.md' discusses this number in detail
  for(u_int16_t i = 0; i < d_cnt; ++i) {
    value |= (1<<i);
  }
  if ((rc = PMUwrmsr(IA32_PERF_GLOBAL_CTRL, value))!=0) {
    return rc;
  }

  return 0;
}


int PMUstart(void) {
  assert(d_fid>0);

  int rc;

  // Enable defined programmable counters (2nd enablement)
  int msr = IA32_PERFEVTSEL0;
  for(u_int16_t i = 0; i < d_cnt; ++i, ++msr) {
    if ((rc = PMUwrmsr(msr, d_pcfg[i]))!=0) {
      return rc;
    }
  }

  return 0;
}






static inline u_int64_t programmableCounterValue(u_int16_t c){
  assert(c < d_cnt);
  u_int64_t a,d;                                                                                                        
  // Finish pending instructions                                                                                        
  __asm __volatile("mfence;lfence");                                                                                           
  // https://www.felixcloutier.com/x86/rdpmc                                                                            
  // https://hjlebbink.github.io/x86doc/html/RDPMC.html                                                                 
  // ECX register: bit 30 <- 0 (programmable cntr) w/ low order bits counter# zero based                                       
  __asm __volatile("rdpmc" : "=a" (a), "=d" (d) : "c" (c));
  // Result is written into EAX lower 32-bits and rest of bits up to counter-width in EDX                               
  return ((d<<32)|a);
}
